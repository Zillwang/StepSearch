import re
def extract_solution(solution_str):
    """Extract the equation from the solution string."""
    # Remove everything before the first "Assistant:"
    # if "Assistant:" in solution_str:
    #     solution_str = solution_str.split("Assistant:", 1)[1]
    # elif "<|im_start|>assistant" in solution_str:
    #     solution_str = solution_str.split("<|im_start|>assistant", 1)[1]
    # else:
    #     return None
    # solution_str = solution_str.split('\n')[-1]

    answer_pattern = r'<answer>(.*?)</answer>'
    match = re.finditer(answer_pattern, solution_str, re.DOTALL)
    matches = list(match)
    
    # If there are 0 or exactly 1 matches, return None
    if len(matches) <= 1:
        return None
    
    # If there are 2 or more matches, return the last one
    return matches[-1].group(1).strip()

def _extract_qwen_solution(sequences_str):
    # Extract the solution from the sequences string
    
    # The solution is the string after the first occurrence of "Assistant"
    return sequences_str.split("<|im_start|>assistant")[-1].strip() 


def _extract_tags(sequences_str):
    if "<|im_start|>assistant" in sequences_str:
        sequences_str = _extract_qwen_solution(sequences_str)
    return sequences_str


def extract_prompt_tags(text):
    """
    Extract the content of various tags from the text generated by the big model

    Supported tags include: <think>, <search>, <information>, <observation>, <turn_answer>, <answer>, etc.

    Parameters:
    text (str): Text generated by the big model containing various tags

    Return:
    dict: A dictionary containing each tag and its content, in the format of {tag name: content}, and a flag indicating whether the format is correct {is_format_valid: bool}
    """
    tags = ["plan","think", "search", "information", "observation", "turn_answer", "answer"]
    results = {}
    
    for tag in tags:
        pattern_start = f"<{tag}>"
        pattern_end = f"</{tag}>"
        
        # Extract all the content of this tag
        contents = []
        start_pos = 0
        
        while True:
            text = _extract_tags(text)
            start_idx = text.find(pattern_start, start_pos)
            if start_idx == -1:
                break
                
            start_idx += len(pattern_start)
            end_idx = text.find(pattern_end, start_idx)
            
            if end_idx == -1:
                break
                
            content = text[start_idx:end_idx].strip()
            contents.append(content)
            start_pos = end_idx + len(pattern_end)
        
        if contents:
            results[tag] = contents
    
    # Verify that the format is correct
    is_format_valid = False
    if all(tag in results for tag in tags):
        # Check if each turn contains "think", "search", "information", "observation", "turn_answer"
        # And whether there is a "think" and "answer" overall
        round_tags = ["plan","think", "search", "information", "observation", "turn_answer"]
        is_format_valid = True
        
        # Make sure the content list of each tag is the same length (one per round)
        round_lengths = [len(results[tag]) for tag in round_tags]
        if len(set(round_lengths)) != 1:
            is_format_valid = False
        else:
            # Check that each round contains all necessary tags
            rounds_count = round_lengths[0]
            for i in range(rounds_count):
                if not all(i < len(results[tag]) for tag in round_tags):
                    is_format_valid = False
                    break
        
        # Make sure you have think and answer
        if "think" not in results or "answer" not in results:
            is_format_valid = False
    
    results["is_format_valid"] = is_format_valid
    return results


if __name__ == "__main__":
    # 测试样例
    test_text = """
    <think>我需要查找Crux的出版商是谁，然后找到它的成立日期</think>
    <search>Crux publisher launch date</search>
    <information>Crux是由CrossFit于2022年7月推出的一本健康和健身杂志</information>
    <observation>从搜索结果中，我可以看到Crux是由CrossFit发布的，而且是在2022年7月推出的</observation>
    <turn_answer>根据搜索结果，我发现Crux是由CrossFit发布的</turn_answer>
    <think>我需要继续搜索CrossFit的成立时间</think>
    <search>CrossFit when founded</search>
    <information>CrossFit是一家美国健身公司，由Greg Glassman和Lauren Jenai于2000年创立</information>
    <observation>从搜索结果中，我得知CrossFit成立于2000年</observation>
    <turn_answer>根据搜索结果，我发现CrossFit成立于2000年</turn_answer>
    <answer>Crux的出版商CrossFit于2000年成立。</answer>
    """
    # return example
    #{'think': ['我需要查找Crux的出版商是谁，然后找到它的成立日期', '我需要继续搜索CrossFit的成立时间'], 'search': ['Crux publisher launch date', 'CrossFit when founded'], 'information': ['Crux是由CrossFit于2022年7月推出的一本健康和健身杂志', 'CrossFit是一家美国健身公司，由Greg Glassman和Lauren Jenai于2000年创立'], 'observation': ['从搜索结果中，我可以看到Crux是由CrossFit发布的，而且是在2022年7月推出的', '从搜索结果中，我得知CrossFit成立于2000年'], 'turn_answer': ['根据搜索结果，我发现Crux是由CrossFit发布的'], 'answer': ['Crux的出版商CrossFit于2000年成立。'], 'is_format_valid': True}
    # 调用函数提取标签内容
    extracted_tags = extract_prompt_tags(test_text)
    
    # 打印结果
    print("提取的标签内容:")
    print(extracted_tags)

